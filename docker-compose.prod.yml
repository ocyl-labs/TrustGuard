# Docker Compose for Production Deployment
# docker-compose.prod.yml

version: '3.8'

services:
  # Main Application
  trustguard-api:
    build:
      context: .
      dockerfile: Dockerfile.prod
    ports:
      - "80:8000"
      - "443:8443"
    environment:
      - FLASK_ENV=production
      - DATABASE_URL=postgresql+asyncpg://trustguard:${DB_PASSWORD}@postgres:5432/trustguard_prod
      - REDIS_URL=redis://redis:6379/0
      - EBAY_APP_ID=${EBAY_APP_ID}
      - STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY}
      - JWT_SECRET=${JWT_SECRET}
      - SENTRY_DSN=${SENTRY_DSN}
    depends_on:
      - postgres
      - redis
    volumes:
      - ./logs:/app/logs
      - ./ssl:/app/ssl
    networks:
      - trustguard-network
    restart: unless-stopped
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
  
  # Database
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=trustguard_prod
      - POSTGRES_USER=trustguard
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backups:/backups
    networks:
      - trustguard-network
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '1.0'
          memory: 2G
    command: >
      postgres 
        -c max_connections=200
        -c shared_buffers=256MB
        -c effective_cache_size=1GB
        -c maintenance_work_mem=64MB
        -c checkpoint_completion_target=0.7
        -c wal_buffers=16MB
        -c default_statistics_target=100
  
  # Redis Cache
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    networks:
      - trustguard-network
    restart: unless-stopped
    command: redis-server --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
  
  # Nginx Load Balancer
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/ssl
      - ./static:/var/www/static
    depends_on:
      - trustguard-api
    networks:
      - trustguard-network
    restart: unless-stopped
  
  # Background Worker for Async Tasks
  worker:
    build:
      context: .
      dockerfile: Dockerfile.worker
    environment:
      - DATABASE_URL=postgresql+asyncpg://trustguard:${DB_PASSWORD}@postgres:5432/trustguard_prod
      - REDIS_URL=redis://redis:6379/0
      - EBAY_APP_ID=${EBAY_APP_ID}
    depends_on:
      - postgres
      - redis
    networks:
      - trustguard-network
    restart: unless-stopped
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
  
  # Monitoring - Prometheus
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    networks:
      - trustguard-network
    restart: unless-stopped
  
  # Monitoring - Grafana
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana:/etc/grafana/provisioning
    networks:
      - trustguard-network
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  prometheus_data:
  grafana_data:

# Dockerfile.prod
FROM python:3.11-slim

# Set work directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    libpq-dev \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN useradd --create-home --shell /bin/bash app \
    && chown -R app:app /app
USER app

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Expose port
EXPOSE 8000

# Run application with Gunicorn
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "--workers", "4", "--worker-class", "uvicorn.workers.UvicornWorker", "--access-logfile", "-", "--error-logfile", "-", "app:app"]

---

# Dockerfile.worker
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create non-root user
RUN useradd --create-home --shell /bin/bash worker \
    && chown -R worker:worker /app
USER worker

# Run worker
CMD ["python", "worker.py"]

---

# nginx/nginx.conf
events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    
    # Logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                   '$status $body_bytes_sent "$http_referer" '
                   '"$http_user_agent" "$http_x_forwarded_for" '
                   'rt=$request_time uct="$upstream_connect_time" '
                   'uht="$upstream_header_time" urt="$upstream_response_time"';
    
    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log warn;
    
    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;
    
    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=100r/m;
    limit_req_zone $binary_remote_addr zone=auth:10m rate=20r/m;
    
    # Upstream backend
    upstream trustguard_backend {
        least_conn;
        server trustguard-api:8000 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }
    
    # HTTP to HTTPS redirect
    server {
        listen 80;
        server_name api.trustguard.com;
        return 301 https://$server_name$request_uri;
    }
    
    # Main HTTPS server
    server {
        listen 443 ssl http2;
        server_name api.trustguard.com;
        
        # SSL configuration
        ssl_certificate /etc/ssl/trustguard.crt;
        ssl_certificate_key /etc/ssl/trustguard.key;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;
        
        # Security headers
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
        add_header X-Content-Type-Options nosniff;
        add_header X-Frame-Options DENY;
        add_header X-XSS-Protection "1; mode=block";
        add_header Referrer-Policy "strict-origin-when-cross-origin";
        
        # API endpoints
        location /api/ {
            limit_req zone=api burst=20 nodelay;
            
            proxy_pass http://trustguard_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeouts
            proxy_connect_timeout 5s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
            
            # Buffering
            proxy_buffering on;
            proxy_buffer_size 8k;
            proxy_buffers 32 8k;
        }
        
        # Auth endpoints (stricter rate limiting)
        location /auth/ {
            limit_req zone=auth burst=5 nodelay;
            
            proxy_pass http://trustguard_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        # Health check
        location /health {
            proxy_pass http://trustguard_backend;
            access_log off;
        }
        
        # Static files
        location /static/ {
            root /var/www;
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
}

---

# requirements.txt
# Core Framework
flask==2.3.3
gunicorn==21.2.0
uvicorn[standard]==0.23.2

# Database
asyncpg==0.28.0
sqlalchemy[asyncio]==2.0.21
alembic==1.12.0
redis==5.0.0

# Authentication & Security
pyjwt==2.8.0
bcrypt==4.0.1
cryptography==41.0.4

# Payment Processing
stripe==6.6.0

# HTTP & API
aiohttp==3.8.6
requests==2.31.0
httpx==0.25.0

# Data Processing
pandas==2.1.1
numpy==1.25.2
scikit-learn==1.3.0

# Image Processing
pillow==10.0.1
opencv-python==4.8.1.78

# Monitoring & Logging
sentry-sdk[flask]==1.32.0
prometheus-client==0.17.1
structlog==23.1.0

# Email
sendgrid==6.10.0

# Utilities
python-dotenv==1.0.0
click==8.1.7
joblib==1.3.2

---

# monitoring/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "rules/*.yml"

scrape_configs:
  - job_name: 'trustguard-api'
    static_configs:
      - targets: ['trustguard-api:8000']
    metrics_path: '/metrics'
    scrape_interval: 10s

  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres:9187']
    scrape_interval: 30s

  - job_name: 'redis'
    static_configs:
      - targets: ['redis:9121']
    scrape_interval: 30s

  - job_name: 'nginx'
    static_configs:
      - targets: ['nginx:9113']
    scrape_interval: 30s

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

---

# scripts/deploy.sh
#!/bin/bash

set -e

echo "üöÄ Starting TrustGuard Production Deployment..."

# Configuration
DEPLOY_ENV=${1:-production}
DOCKER_COMPOSE_FILE="docker-compose.prod.yml"
BACKUP_DIR="./backups/$(date +%Y%m%d_%H%M%S)"

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $1${NC}"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1${NC}"
    exit 1
}

# Pre-deployment checks
log "Running pre-deployment checks..."

# Check if required files exist
required_files=(
    ".env.prod"
    "$DOCKER_COMPOSE_FILE"
    "nginx/nginx.conf"
    "ssl/trustguard.crt"
    "ssl/trustguard.key"
)

for file in "${required_files[@]}"; do
    if [[ ! -f "$file" ]]; then
        error "Required file not found: $file"
    fi
done

# Check if required environment variables are set
source .env.prod
required_vars=(
    "DB_PASSWORD"
    "EBAY_APP_ID"
    "STRIPE_SECRET_KEY"
    "JWT_SECRET"
)

for var in "${required_vars[@]}"; do
    if [[ -z "${!var}" ]]; then
        error "Required environment variable not set: $var"
    fi
done

log "‚úÖ Pre-deployment checks passed"

# Create backup
log "Creating backup..."
mkdir -p "$BACKUP_DIR"

if docker-compose -f "$DOCKER_COMPOSE_FILE" ps -q postgres | grep -q .; then
    log "Backing up database..."
    docker-compose -f "$DOCKER_COMPOSE_FILE" exec -T postgres pg_dump -U trustguard trustguard_prod > "$BACKUP_DIR/database_backup.sql"
    log "‚úÖ Database backup created: $BACKUP_DIR/database_backup.sql"
fi

# Build and deploy
log "Building Docker images..."
docker-compose -f "$DOCKER_COMPOSE_FILE" build --no-cache

log "Starting services..."
docker-compose -f "$DOCKER_COMPOSE_FILE" up -d

# Wait for services to be healthy
log "Waiting for services to be healthy..."
max_attempts=30
attempt=0

while [[ $attempt -lt $max_attempts ]]; do
    if docker-compose -f "$DOCKER_COMPOSE_FILE" exec trustguard-api curl -f http://localhost:8000/health >/dev/null 2>&1; then
        log "‚úÖ API service is healthy"
        break
    fi
    
    attempt=$((attempt + 1))
    log "Waiting for API service... ($attempt/$max_attempts)"
    sleep 10
done

if [[ $attempt -eq $max_attempts ]]; then
    error "API service failed to become healthy"
fi

# Run database migrations
log "Running database migrations..."
docker-compose -f "$DOCKER_COMPOSE_FILE" exec trustguard-api python -m alembic upgrade head

# Verify deployment
log "Verifying deployment..."
API_HEALTH=$(docker-compose -f "$DOCKER_COMPOSE_FILE" exec -T trustguard-api curl -s http://localhost:8000/health | python -c "import sys, json; print(json.load(sys.stdin).get('status', 'unknown'))")

if [[ "$API_HEALTH" == "healthy" ]]; then
    log "‚úÖ Deployment verification passed"
else
    error "Deployment verification failed: API health status is $API_HEALTH"
fi

# Cleanup old images
log "Cleaning up old Docker images..."
docker image prune -f

log "üéâ Deployment completed successfully!"
log "üìä Monitor your application:"
log "   - API Health: https://api.trustguard.com/health"
log "   - Grafana Dashboard: http://your-server:3000"
log "   - Prometheus Metrics: http://your-server:9090"

# Display service status
log "üìã Service Status:"
docker-compose -f "$DOCKER_COMPOSE_FILE" ps

---

# scripts/backup.sh
#!/bin/bash

set -e

BACKUP_DIR="./backups/$(date +%Y%m%d_%H%M%S)"
DOCKER_COMPOSE_FILE="docker-compose.prod.yml"

echo "üîÑ Creating backup..."

mkdir -p "$BACKUP_DIR"

# Database backup
echo "üìä Backing up database..."
docker-compose -f "$DOCKER_COMPOSE_FILE" exec -T postgres pg_dump -U trustguard trustguard_prod | gzip > "$BACKUP_DIR/database.sql.gz"

# Redis backup
echo "üì¶ Backing up Redis..."
docker-compose -f "$DOCKER_COMPOSE_FILE" exec redis redis-cli BGSAVE
docker cp $(docker-compose -f "$DOCKER_COMPOSE_FILE" ps -q redis):/data/dump.rdb "$BACKUP_DIR/redis_dump.rdb"

# Application files
echo "üìÅ Backing up application files..."
tar -czf "$BACKUP_DIR/app_files.tar.gz" --exclude='node_modules' --exclude='__pycache__' --exclude='*.pyc' .

# Upload to cloud storage (optional)
if [[ -n "$AWS_S3_BACKUP_BUCKET" ]]; then
    echo "‚òÅÔ∏è Uploading to S3..."
    aws s3 sync "$BACKUP_DIR" "s3://$AWS_S3_BACKUP_BUCKET/trustguard/$(basename $BACKUP_DIR)/"
fi

echo "‚úÖ Backup completed: $BACKUP_DIR"

# Cleanup old backups (keep last 7 days)
find ./backups -type d -mtime +7 -exec rm -rf {} +

---

# scripts/rollback.sh
#!/bin/bash

set -e

BACKUP_DATE=${1:-$(ls -1 ./backups | tail -n 1)}
BACKUP_DIR="./backups/$BACKUP_DATE"
DOCKER_COMPOSE_FILE="docker-compose.prod.yml"

echo "üîÑ Rolling back to backup: $BACKUP_DATE"

if [[ ! -d "$BACKUP_DIR" ]]; then
    echo "‚ùå Backup directory not found: $BACKUP_DIR"
    exit 1
fi

# Stop current services
echo "üõë Stopping current services..."
docker-compose -f "$DOCKER_COMPOSE_FILE" down

# Restore database
if [[ -f "$BACKUP_DIR/database.sql.gz" ]]; then
    echo "üìä Restoring database..."
    docker-compose -f "$DOCKER_COMPOSE_FILE" up -d postgres
    sleep 10
    
    gunzip -c "$BACKUP_DIR/database.sql.gz" | docker-compose -f "$DOCKER_COMPOSE_FILE" exec -T postgres psql -U trustguard -d trustguard_prod
fi

# Restore Redis
if [[ -f "$BACKUP_DIR/redis_dump.rdb" ]]; then
    echo "üì¶ Restoring Redis..."
    docker cp "$BACKUP_DIR/redis_dump.rdb" $(docker-compose -f "$DOCKER_COMPOSE_FILE" ps -q redis):/data/dump.rdb
fi

# Start all services
echo "üöÄ Starting services..."
docker-compose -f "$DOCKER_COMPOSE_FILE" up -d

echo "‚úÖ Rollback completed"

---

# monitoring/grafana/dashboards/trustguard.json
{
  "dashboard": {
    "id": null,
    "title": "TrustGuard Metrics",
    "tags": ["trustguard"],
    "timezone": "browser",
    "panels": [
      {
        "id": 1,
        "title": "API Requests per Second",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(flask_http_request_total[5m])",
            "legendFormat": "{{method}} {{endpoint}}"
          }
        ],
        "yAxes": [
          {
            "label": "Requests/sec"
          }
        ]
      },
      {
        "id": 2,
        "title": "Response Times",
        "type": "graph",
        "targets": [
          {
            "expr": "flask_http_request_duration_seconds",
            "legendFormat": "{{method}} {{endpoint}}"
          }
        ],
        "yAxes": [
          {
            "label": "Seconds"
          }
        ]
      },
      {
        "id": 3,
        "title": "Error Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(flask_http_request_exceptions_total[5m])",
            "legendFormat": "{{exception}}"
          }
        ]
      },
      {
        "id": 4,
        "title": "Database Connections",
        "type": "singlestat",
        "targets": [
          {
            "expr": "pg_stat_database_numbackends{datname=\"trustguard_prod\"}"
          }
        ]
      },
      {
        "id": 5,
        "title": "Redis Memory Usage",
        "type": "singlestat",
        "targets": [
          {
            "expr": "redis_memory_used_bytes"
          }
        ],
        "format": "bytes"
      }
    ],
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "refresh": "10s"
  }
}

---

# .env.prod.example
# Database
DB_PASSWORD=your_secure_database_password

# eBay API
EBAY_APP_ID=your_ebay_app_id
EBAY_CERT_ID=your_ebay_cert_id
EBAY_DEV_ID=your_ebay_dev_id

# Stripe
STRIPE_SECRET_KEY=sk_live_your_stripe_secret_key
STRIPE_PUBLISHABLE_KEY=pk_live_your_stripe_publishable_key
STRIPE_WEBHOOK_SECRET=whsec_your_webhook_secret

# Security
JWT_SECRET=your_jwt_secret_key_at_least_32_characters

# Monitoring
SENTRY_DSN=https://your-sentry-dsn
GRAFANA_PASSWORD=your_grafana_admin_password

# Email
SENDGRID_API_KEY=your_sendgrid_api_key

# AWS (for backups)
AWS_ACCESS_KEY_ID=your_aws_access_key
AWS_SECRET_ACCESS_KEY=your_aws_secret_key
AWS_S3_BACKUP_BUCKET=trustguard-backups

# Domain
DOMAIN=trustguard.com
API_DOMAIN=api.trustguard.com
